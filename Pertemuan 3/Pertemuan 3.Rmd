---
title: "Pertemuan 3 - Regresi dengan Peubah Lag"
author:
- Nabil Naufal
output:
  html_document:
    theme: yeti
    toc: true
    toc_float: true
  word_document: default
  pdf_document: default
---

## Pendahuluan: Mengapa Kita Butuh Peubah Lag?

Selamat datang di pertemuan ketiga! Hari ini kita akan membahas sebuah konsep yang sangat penting dalam analisis deret waktu: **efek dari masa lalu**.

Dalam regresi biasa, kita mengasumsikan bahwa $X$ pada waktu $t$ memengaruhi $Y$ pada waktu $t$ juga $(X_t\rightarrow Y_t)$. Tapi, di dunia nyata, efek sebuah peristiwa seringkali tidak instan.

-   Efek dari kampanye iklan (*marketing spend*) hari ini mungkin baru terasa pada penjualan minggu depan.

-   Kenaikan suku bunga oleh bank sentral mungkin baru memengaruhi inflasi beberapa bulan kemudian.

Untuk menangani "keterlambatan efek" ini, kita menggunakan **regresi dengan peubah lag**. Tujuannya adalah untuk memodelkan bagaimana $Y_t$ dipengaruhi oleh nilai $X$ dari masa lalu $(X_{t−1},X_{t−2},\dots)$ dan bahkan oleh nilai Y itu sendiri dari masa lalu $(Y_{t−1},Y_{t−2},\dots)$.

**Alur Belajar Kita Hari Ini:**

1.  **Model Koyck:** Model elegan yang mengasumsikan pengaruh masa lalu **memudar secara geometris**.

2.  **Model Distributed Lag (DLM):** Model fleksibel yang membiarkan data "berbicara" tentang pengaruh setiap lag.

3.  **Model Autoregressive DLM (ARDL):** Model hibrida yang paling lengkap, menggabungkan efek lag dari X dan Y.

4.  **Perbandingan:** Memilih model terbaik untuk data kita.

## *Packages*

```{r, echo=FALSE}
#PACKAGES
#install.packages("dLagM") #install jika belum ada
#install.packages("dynlm") #install jika belum ada
#install.packages("MLmetrics") #install jika belum ada
library(dLagM)
library(dynlm)
library(MLmetrics)
library(lmtest)
library(car)
```

## Impor Data

```{r}
data <- rio::import("https://raw.githubusercontent.com/rizkynurhambali/praktikum-sta1341/main/Pertemuan%203/Data%20Asli.csv")
str(data)
data
```

## Pembagian Data

```{r}
#SPLIT DATA
train<-data[1:15,]
test<-data[16:20,]
```

```{r}
#data time series
train.ts<-ts(train)
test.ts<-ts(test)
data.ts<-ts(data)
```

## Model Koyck

**Intuisi:** Model Koyck memiliki asumsi yang sangat cerdas: **pengaruh dari masa lalu akan semakin melemah seiring berjalannya waktu**.

-   **Analogi:** Bayangkan ingatan tentang sebuah konser. Sehari setelahnya, ingatan Anda masih sangat jelas. Seminggu kemudian, sedikit memudar. Sebulan kemudian, Anda mungkin hanya ingat beberapa bagian saja.

Secara matematis, Koyck menyederhanakan model yang memiliki tak hingga lag menjadi model yang jauh lebih simpel dengan memasukkan **lag dari variabel dependen** $(Y_{t−1})$ sebagai salah satu prediktor. $Y_{t−1}$ ini secara implisit sudah merangkum semua informasi dari lag X di masa lalu.

**Formula Umum:**

$$ y_t=a(1-\lambda)+\beta_0X_t+\beta_1Z_t+\lambda Y_{t-1}+V_t $$

dengan $$V_t=u_t-\lambda u_{t-1}$$

Di mana $\lambda$ (koefisien dari $Y_{t−1}$) menunjukkan "tingkat peluruhan" atau seberapa cepat pengaruh masa lalu memudar.

### Pemodelan

Pemodelan model Koyck dengan `R` dapat menggunakan `dLagM::koyckDlm()` . Fungsi umum dari `koyckDlm` adalah sebagai berikut.

```{r, eval=FALSE, message = FALSE, warning=FALSE, error=FALSE}
koyckDlm(x , y , intercept)
```

Fungsi `koyckDlm()` akan menerapkan model lag terdistribusi dengan transformasi Koyck satu prediktor. Nilai `x` dan `y` tidak perlu sebagai objek *time series* (`ts`). `intercept` dapat dibuat `TRUE` untuk memasukkan intersep ke dalam model.

```{r}
#MODEL KOYCK
model.koyck <- koyckDlm(x = train$Xt, y = train$Yt)
summary(model.koyck)
AIC(model.koyck)
BIC(model.koyck)
```

**Interpretasi Hasil:**

-   Dari `summary`, kita dapatkan model:

    $$ \hat{Y_t}=-3.7335+1.1510X_t+0.4214Y_{t-1} $$

    Koefisien $X_t$ (1.1510) signifikan, artinya nilai \$X\$ saat ini berpengaruh terhadap $Y$.

-   Koefisien $Y_{t−1}$ (0.4214) juga signifikan. Ini adalah **estimasi untuk** $\lambda$. Nilai ini menunjukkan bahwa sekitar 42% dari efek di periode sebelumnya masih "terbawa" ke periode saat ini.

### Peramalan dan Akurasi

Berikut adalah hasil peramalan y untuk 5 periode kedepan menggunakan model koyck

```{r}
fore.koyck <- forecast(model = model.koyck, x=test$Xt, h=5)
fore.koyck
mape.koyck <- MAPE(fore.koyck$forecasts, test$Yt)
mape.koyck #data test
#akurasi data training
GoF(model.koyck)
```

## Regression with Distributed Lag

**Intuisi:** Bagaimana jika pengaruh masa lalu tidak selalu memudar secara mulus? Mungkin efek iklan di dua minggu lalu lebih besar daripada seminggu lalu. Model DLM lebih fleksibel. Ia **tidak membuat asumsi** tentang pola peluruhan pengaruh. Sebaliknya, ia mencoba mengestimasi koefisien untuk **setiap lag secara terpisah**.

**Tantangan:** Pertanyaan utamanya adalah, "Berapa banyak lag dari masa lalu yang harus kita masukkan?" Terlalu sedikit bisa menghilangkan informasi penting, terlalu banyak bisa membuat model terlalu kompleks (*overfitting*).

Pemodelan model Regression with Distributed Lag dengan `R` dapat menggunakan `dLagM::dlm()` . Fungsi umum dari `dlm` adalah sebagai berikut.

```{r, eval=FALSE, error=FALSE}
dlm(formula , data , x , y , q , remove )
```

Fungsi `dlm()` akan menerapkan model lag terdistribusi dengan satu atau lebih prediktor. Nilai `x` dan `y` tidak perlu sebagai objek *time series* (`ts`). $q$ adalah integer yang mewakili panjang *lag* yang terbatas.

### Pemodelan (Lag=2)

```{r}
model.dlm <- dlm(x = train$Xt,y = train$Yt , q = 2)
summary(model.dlm)
AIC(model.dlm)
BIC(model.dlm)
```

Dari hasil diatas, didapat bahwa $P-value$ dari intercept dan $x_{t-1}<0.05$. Hal ini menunjukkan bahwa intercept dan $x_{t-1}$ berpengaruh signifikan terhadap $y$. Adapun model keseluruhan yang terbentuk adalah sebagai berikut

$$
\hat{Y_t}=-9.6779+0.3179X_t+1.5276X_{t-1}+0.2651X_{t-2}
$$

### Peramalan dan Akurasi

Berikut merupakan hasil peramalan $y$ untuk 5 periode kedepan

```{r}
fore.dlm <- forecast(model = model.dlm, x=test$Xt, h=5)
fore.dlm
mape.dlm <- MAPE(fore.dlm$forecasts, test$Yt)
mape.dlm
#akurasi data training
GoF(model.dlm)
```

### *Lag* Optimum

Daripada menebak, kita bisa meminta R untuk mencari panjang lag yang paling optimal berdasarkan kriteria informasi seperti **AIC (Akaike Information Criterion)**. AIC menyeimbangkan antara kecocokan model dengan kompleksitasnya.

```{r}
#penentuan lag optimum 
finiteDLMauto(formula = Yt ~ Xt,
              data = data.frame(train), q.min = 1, q.max = 10,
              model.type = "dlm", error.type = "AIC", trace = TRUE)
```

Berdasarkan output tersebut, lag optimum didapatkan ketika lag=6. Selanjutnya dilakukan pemodelan untuk lag=6

```{r}
#model dlm dengan lag optimum
model.dlm2 <- dlm(x = train$Xt,y = train$Yt , q = 6)
summary(model.dlm2)
AIC(model.dlm2)
BIC(model.dlm2)
```

Dari hasil tersebut terdapat beberapa peubah yang berpengaruh signifikan terhadap taraf nyata 5% yaitu $x_t$ , $x_{t-2}$ , $x_{t-4}$ , $x_{t-6}$. Adapun keseluruhan model yang terbentuk adalah

$$
\hat{Y_t}=21.42223+1.68749X_t+...-3.47612X_{t-6}
$$

Adapun hasil peramalan 5 periode kedepan menggunakan model tersebut adalah sebagai berikut

```{r}
#peramalan dan akurasi
fore.dlm2 <- forecast(model = model.dlm2, x=test$Xt, h=5)

#akurasi data test
mape.dlm2<- MAPE(fore.dlm2$forecasts, test$Yt)
mape.dlm2

#akurasi data training
GoF(model.dlm2)
```

Model tersebut merupakan model yang sangat baik dengan nilai MAPE yang kurang dari 10%.

## Model Autoregressive

**Intuisi:** ARDL adalah model "hibrida" yang paling lengkap. Ia menggabungkan dua ide:

1.  **Distributed Lag (DL):** $Y_t$ dipengaruhi oleh nilai X di masa lalu $(X_{t−1},X_{t−2},\dots)$.

2.  **Autoregressive (AR):** Y_t juga dipengaruhi oleh nilainya sendiri di masa lalu $(Y_{t−1},Y_{t−2},\dots)$. Ini menangkap adanya "momentum" atau "inersia" dalam data.

Model ini sangat populer dalam ekonometrika. Kita menyebutnya model **ARDL(p, q)**, di mana `p` adalah jumlah lag untuk Y dan `q` adalah jumlah lag untuk X.

### Pemodelan

Pemodelan Autoregressive dilakukan menggunakan fungsi `dLagM::ardlDlm()` . Fungsi tersebut akan menerapkan *autoregressive* berordo $(p,q)$ dengan satu prediktor. Fungsi umum dari `ardlDlm()` adalah sebagai berikut.

```{r, eval=FALSE}
ardlDlm(formula = NULL , data = NULL , x = NULL , y = NULL , p = 1 , q = 1 , 
         remove = NULL )
```

Dengan $p$ adalah integer yang mewakili panjang *lag* yang terbatas dan $q$ adalah integer yang merepresentasikan ordo dari proses *autoregressive*.

```{r}
model.ardl <- ardlDlm(x = train$Xt, y = train$Yt, p = 1 , q = 1)
summary(model.ardl)
AIC(model.ardl)
BIC(model.ardl)
```

```{r}
model.ardl <- ardlDlm(formula = Yt ~ Xt, 
                         data = train,p = 1 , q = 1)
summary(model.ardl)
AIC(model.ardl)
BIC(model.ardl)
```

Hasil di atas menunjukkan bahwa selain peubah $x_{t-1}$, hasil uji t menunjukkan nilai-p pada peubah $\ge0.05$ Hal ini menunjukkan bahwa peubah $x_{t-1}$ berpengaruh signifikan terhadap $y_t$, sementara $x_t$ dan $y_{t-1}$ berpengaruh signifikan terhadap $y_t$. Model keseluruhannya adalah sebagai berikut:

$$
\hat{Y}=-8,3594+0,3563X_t+1,4557X_{t-1}+0,1408Y_{t-1}
$$

### Peramalan dan Akurasi

```{r}
fore.ardl <- forecast(model = model.ardl, x=test$Xt, h=5)
fore.ardl
```

Data di atas merupakan hasil peramalan untuk 5 periode ke depan menggunakan Model Autoregressive dengan $p=1$ dan $q=1$.

```{r}
mape.ardl <- MAPE(fore.ardl$forecasts, test$Yt)
mape.ardl
#akurasi data training
GoF(model.ardl)
```

Berdasarkan akurasi di atas, terlihat bahwa nilai MAPE keduanya tidak jauh berbeda. Artinya, model regresi dengan distribusi lag ini tidak`overfitted` atau `underfitted`

### *Lag* Optimum

```{r}
#penentuan lag optimum
model.ardl.opt <- ardlBoundOrders(data = data.frame(data), ic = "AIC", 
                                  formula = Yt ~ Xt )
model.ardl.opt
min_p=c()
for(i in 1:6){
  min_p[i]=min(model.ardl.opt$Stat.table[[i]])
}
q_opt=which(min_p==min(min_p, na.rm = TRUE))
p_opt=which(model.ardl.opt$Stat.table[[q_opt]] == 
              min(model.ardl.opt$Stat.table[[q_opt]], na.rm = TRUE))
data.frame("q_optimum" = q_opt, "p_optimum" = p_opt, 
           "AIC"=model.ardl.opt$min.Stat)
```

```{r}
model.ardl2 <- ardlDlm(formula = Yt ~ Xt, 
                         data = train,p = 5, q = 4)
summary(model.ardl2)
```

Dari tabel di atas, dapat terlihat bahwa nilai AIC terendah didapat ketika $p=6$ dan $q=1$, yaitu sebesar `-20,56587`. Artinya, model autoregressive optimum didapat ketika $p=6$ dan $q=1$.

Selanjutnya dapat dilakukan pemodelan dengan nilai $p$ dan $q$ optimum seperti inisialisasi di langkah sebelumnya.

## Pemodelan DLM & ARDL dengan Library `dynlm`

Pemodelan regresi dengan peubah *lag* tidak hanya dapat dilakukan dengan fungsi pada *packages* `dLagM` , tetapi terdapat *packages* `dynlm` yang dapat digunakan. Fungsi `dynlm` secara umum adalah sebagai berikut.

```{r, eval=FALSE}
dynlm(formula, data, subset, weights, na.action, method = "qr",
  model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
  contrasts = NULL, offset, start = NULL, end = NULL, ...)
```

Untuk menentukan `formula` model yang akan digunakan, tersedia fungsi tambahan yang memungkinkan spesifikasi dinamika (melalui `d()` dan `L()`) atau pola linier/siklus dengan mudah (melalui `trend()`, `season()`, dan `harmon()`). Semua fungsi formula baru mengharuskan argumennya berupa objek deret waktu (yaitu, `"ts"` atau `"zoo"`).

```{r}
#sama dengan model dlm q=1
cons_lm1 <- dynlm(Yt ~ Xt+L(Xt),data = train.ts)
#sama dengan model ardl p=1 q=0
cons_lm2 <- dynlm(Yt ~ Xt+L(Yt),data = train.ts)
#sama dengan ardl p=1 q=1
cons_lm3 <- dynlm(Yt ~ Xt+L(Xt)+L(Yt),data = train.ts)
#sama dengan dlm p=2
cons_lm4 <- dynlm(Yt ~ Xt+L(Xt)+L(Xt,2),data = train.ts)
```

### Ringkasan Model

```{r}
summary(cons_lm1)
summary(cons_lm2)
summary(cons_lm3)
summary(cons_lm4)
```

### SSE

```{r}
deviance(cons_lm1)
deviance(cons_lm2)
deviance(cons_lm3)
deviance(cons_lm4)
```

### Uji Diagnostik

```{r}
#uji model
if(require("lmtest")) encomptest(cons_lm1, cons_lm2)
```

#### Autokorelasi

```{r}
#durbin watson
dwtest(cons_lm1)
dwtest(cons_lm2)
dwtest(cons_lm3)
dwtest(cons_lm4)
```

#### Heterogenitas

```{r}
bptest(cons_lm1)
bptest(cons_lm2)
bptest(cons_lm3)
bptest(cons_lm4)
```

#### Kenormalan

```{r}
shapiro.test(residuals(cons_lm1))
shapiro.test(residuals(cons_lm2))
shapiro.test(residuals(cons_lm3))
shapiro.test(residuals(cons_lm4))
```

## Perbandingan Model

```{r}
akurasi <- matrix(c(mape.koyck, mape.dlm, mape.dlm2, mape.ardl))
row.names(akurasi)<- c("Koyck","DLM 1","DLM 2","Autoregressive")
colnames(akurasi) <- c("MAPE")
akurasi
```

Berdasarkan nilai MAPE, model paling optimum didapat pada Model Koyck karena memiliki nilai MAPE yang terkecil.

### Plot

```{r}
par(mfrow=c(1,1))
plot(test$Xt, test$Yt, type="b", col="black", ylim=c(120,250))
points(test$Xt, fore.koyck$forecasts,col="red")
lines(test$Xt, fore.koyck$forecasts,col="red")
points(test$Xt, fore.dlm$forecasts,col="blue")
lines(test$Xt, fore.dlm$forecasts,col="blue")
points(test$Xt, fore.dlm2$forecasts,col="orange")
lines(test$Xt, fore.dlm2$forecasts,col="orange")
points(test$Xt, fore.ardl$forecasts,col="green")
lines(test$Xt, fore.ardl$forecasts,col="green")
legend("topleft",c("aktual", "koyck","DLM 1","DLM 2", "autoregressive"), lty=1, col=c("black","red","blue","orange","green"), cex=0.8)
```

Berdasarkan plot tersebut, terlihat bahwa plot yang paling mendekati data aktualnya adalah Model koyck, sehingga dapat disimpulkan model terbaik dalam hal ini adalah model regresi koyck

## Pengayaan (Regresi Berganda)

### Data

```{r}
data(M1Germany)
data1 = M1Germany[1:144,]
data1
```

### DLM

```{r}
#Run the search over finite DLMs according to AIC values
finiteDLMauto(formula = logprice ~ interest+logm1,
              data = data.frame(data1), q.min = 1, q.max = 5,
              model.type = "dlm", error.type = "AIC", trace = FALSE)
```

```{r}
#model dlm berganda
model.dlmberganda = dlm(formula = logprice ~ interest + logm1,
                data = data.frame(data1) , q = 5)
summary(model.dlmberganda)

model.dlmberganda2 = dlm(formula = logprice ~ interest + logm1,
                        data = data.frame(data1) , q = 1)
summary(model.dlmberganda2)
```

### ARDL

```{r}
#Mencari orde lag optimum model ARDL
ardlBoundOrders(data = data1 , formula = logprice ~ interest + logm1,
                ic="AIC")

model.ardlDlmberganda = ardlDlm(formula = logprice ~ interest + logm1,
                        data = data.frame(data1) , p = 4 , q = 4)
summary(model.ardlDlmberganda)
```

```{r}
#model p interest 0 p logm1 4 
rem.p = list(interest = c(1,2,3,4))
remove = list(p = rem.p)
model.ardlDlmberganda2 = ardlDlm(formula = logprice ~ interest + logm1,
                        data = data.frame(data1) , p = 4 , q = 4 ,
                        remove = remove)
summary(model.ardlDlmberganda2)
```

Proses selanjutnya sama dengan pemodelan menggunakan peubah tunggal.
